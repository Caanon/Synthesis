
/* Generated by Interface Builder */

#import "Gaussian.h"
#import <PseudoRandomNum/PRNGenerator.h>
#import <Desiderata/NSValueArray.h>
#import <stdio.h>

@implementation Gaussian

- (void) initializeWithCellType:(SIMType *)aType
{
    [super initializeWithCellType:aType];
    [self setRandomNumberSeed:1];
}


- (NSValueArray *)connectionsForPosition:(SIMPosition)position
{
	SIMConnection	*tempConnect,aConnect;
	NSMutableValueArray *connections;
   	float		i,j,count;
	float		size_2 = size/2;
	float		scale = 2*M_PI/size; 
	float		temp;	  			   
	double		r;

	tempConnect = NSZoneMalloc([self zone], sizeof(SIMConnection));
		
	connections = [[NSMutableValueArray allocWithZone:[self zone]]
					initWithValues:nil
					count:size*2 // estimate of number of connections
					withObjCType:@encode(SIMConnection)];


    for (i=-size_2;i <= size_2;i++){
        for(j=-size_2;j <= size_2;j++) {
	    temp= (height*exp(-((pow(i*scale,2)+pow(j*scale,2))/width)))+constant;
            if(!width)temp = constant;
			tempConnect->strength = 0.0;
            tempConnect->latency = (float)[delayGenerator nextDouble];
			if ([type isEqual:GS_SmoothConnection]){
				tempConnect->dx = j ;
				tempConnect->dy = i ;
				tempConnect->dz = 0;
				tempConnect->strength = temp*strength;
			}
            else if ([type isEqual:GS_RandomSmoothConnection]){
                    tempConnect->dx = j;
                    tempConnect->dy = i;
                    tempConnect->dz = 0;
                    tempConnect->strength=temp*strength+[generator nextDouble];
            }
			else {
				r = [generator nextDouble];
				tempConnect->dx = j ;
				tempConnect->dy = i ;
				tempConnect->dz = 0;
				if (r<fabs(temp)) {
					if([type isEqual:GS_GaussianStrengthConnection]) tempConnect->strength = [strengthGenerator nextDouble];
					else if([type isEqual:GS_SparseSmoothConnection]) tempConnect->strength = strength*temp;
					else tempConnect->strength = strength;
				}
			}
			if(addNullConnectionsFlag || (tempConnect->strength != 0.0))[connections addValue:(void *)tempConnect];
        }
    }

    if (normalized){
            count = [connections count];
            for(i=0;i<count;i++){
                    [connections getValue:&aConnect atIndex:i];
                    aConnect.strength /= count;
                    [connections replaceValue:&aConnect atIndex:i];
            }
    }
	
    NSZoneFree([self zone],tempConnect);
    //[SIMConnections logConnections:connections];
    return [connections autorelease];
}


- (oneway void)updateParameters
{
    [super updateParameters];


    height = [self floatForKey:GSHeight];
    width = [self floatForKey:GSWidth];
    radius = [self intForKey:GSRadius];
    size = radius*2+1.0;
    strength = [self floatForKey:GSStrength];
    constant = [self floatForKey:GSConstant];

    strengthStd = [self floatForKey:GSStrengthStd];

    type = [self objectForKey:GSType];
    normalized = [self boolForKey:GSNormalized];
	addNullConnectionsFlag = [self boolForKey:@"AllowNullConnections"];

    [self setRandomNumberSeed:[self randomNumberSeed]];

}

- (void) setRandomNumberSeed:(int)seed
{
    float stdDelay, meanDelay;

    [super setRandomNumberSeed:seed];
    
    stdDelay = [self floatForKey:GSStdDelay];
    meanDelay = [self floatForKey:GSMeanDelay];    
    
    if(generator)[generator release];
    if ([type isEqual: GS_SobolConnection]){
        generator = [[PRNGenerator sobolGenerator] retain];
        [(PRNSobolGenerator *)generator setNumSequences:2];
        // Get rid of the initial zero(es).
        [generator nextDouble];[generator nextDouble];
    }
    else if ([type isEqual: GS_RandomConnection])
            generator = [[PRNGenerator marsagliaGenerator] retain];
    else if ([type isEqual: GS_RandomSmoothConnection]){
        generator = [[PRNGenerator gaussianGenerator] retain];
        [(PRNGaussianGenerator *)generator setMean:0.0];
        [(PRNGaussianGenerator *)generator setStd:strengthStd];
    }
    else if ([type isEqual: GS_GaussianStrengthConnection]){
        generator = [[PRNGenerator marsagliaGenerator] retain];
        strengthGenerator = [[PRNGenerator gaussianGenerator] retain];
        [(PRNGaussianGenerator *)strengthGenerator setMean:strength];
        [(PRNGaussianGenerator *)strengthGenerator setStd:strengthStd];
    }
    else generator = [[PRNGenerator marsagliaGenerator] retain];

    if(delayGenerator)[delayGenerator release];
    delayGenerator = [[PRNGenerator gaussianGenerator] retain];
    [(PRNGaussianGenerator *)delayGenerator setMean:meanDelay];
    [(PRNGaussianGenerator *)delayGenerator setStd:stdDelay];

    [generator setSeed:seed+1];
    [strengthGenerator setSeed:seed+2];
    [delayGenerator setSeed:seed+3];

}


- (void)dealloc
{
	[generator release];
        [strengthGenerator release];
        [delayGenerator release];
    	if(userState.connections)[userState.connections release];
	[super dealloc];
}
@end

