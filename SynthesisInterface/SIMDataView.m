
/* Generated by Interface Builder */

#import "SIMDataView.h"
#import <stdlib.h>
#import <Foundation/NSString.h>


#define min(x,y) ((x)<(y) ? (x):(y))
#define max(x,y) ((x)>(y) ? (x):(y))


@implementation SIMDataView

- initWithFrame:(NSRect)frameRect
{
	
// Initialize the View and the variables describing the boundaries

    [super initWithFrame:frameRect];
    
    elementLoc.x = 0.0;
    elementLoc.y = 0.0;
    
    tiff = nil;
    tiffWidth = 10;
    tiffHeight = 10;
    dataMin =  FLT_MAX;
    dataMax =  -FLT_MAX;
    refValue = 0.0;

    tiffInverse = YES;
    autoScale = YES;
    preserveAspectRatio = YES;

    return self;
}

- (BOOL)isOpaque
{
    return YES;
}

- initSize:(int)xsize :(int)ysize
{
    tiffWidth = xsize;
    tiffHeight = ysize;

    if(tiff)[tiff release];
    tiff = [[NSBitmapImageRep alloc]
                initWithBitmapDataPlanes:NULL
                pixelsWide:tiffWidth
                pixelsHigh:tiffHeight
                bitsPerSample:8
                samplesPerPixel:1
                hasAlpha:NO
                isPlanar:YES
                colorSpaceName:tiffInverse ? NSCalibratedWhiteColorSpace : NSCalibratedBlackColorSpace
                bytesPerRow:tiffWidth
                bitsPerPixel:8];

    if(!tiff){
            NSLog(@"Couldn't create the tiff!\n");
            return self;
    }

    //[tiff getBitmapDataPlanes:imageData];

    return self;
}


- (void)drawRect:(NSRect)rect
// This is the routine where everything really happens
// The background of the view is drawn and then the function itself
// is calculated.  The parameters used are global to this class, so
// the sliders can change them at any time.
{	        
	[super drawRect:rect];
		
	border = [self bounds];	
	
	if(preserveAspectRatio){
	    float	imageRatio;
	
	    [[[self window] backgroundColor] set];
	    NSRectFill([self bounds]);

	    imageRatio = 
	MIN(((border.size.width)/tiffWidth),(border.size.height/tiffHeight));
	
	    border.size.width = tiffWidth*imageRatio;
	    border.size.height = tiffHeight*imageRatio;
	    border.origin.x += (([self bounds].size.width)/2) - 
		    (border.size.width/2);
	    border.origin.y += ([self bounds].size.height/2) - 
		    (border.size.height/2);
	}
	
	if(tiff){
		if(imageSmoothingFlag)[[NSGraphicsContext currentContext] setImageInterpolation:NSImageInterpolationLow];
		else [[NSGraphicsContext currentContext] setImageInterpolation:NSImageInterpolationNone];
		[tiff drawInRect:border];
	}
}

- setImageSmoothing:(BOOL)smooth;
{
	imageSmoothingFlag = smooth;
    [self displayIfNeeded];
	return self;
}

- (void)_setAutoScale
{
	int	i,j;
	const NSSwappedFloat *dataptr = [dataObject bytes];

	if(autoScale){
    	dataMin =  FLT_MAX;
    	dataMax =  -FLT_MAX;

	  /* find minimum and maximum values */

        for (i = 0; i < tiffHeight; i++){
            for (j = 0; j < tiffWidth; j++) {
                int	index = (i*tiffWidth)+j;
                float val;
                if(swapBytesFlag)
                    val =  NSSwapBigFloatToHost(dataptr[index]);
                else
	            val =  NSConvertSwappedFloatToHost(dataptr[index]);
                dataMin = MIN(val,dataMin);
                dataMax = MAX(val,dataMax);
            }
        }
	}
        dataMin = MIN(refValue,dataMin);
        dataMax = MAX(refValue,dataMax);

        if(dataMax==dataMin) {
            scale = 1.0;
            if (dataMax == 0.0) dataMax = 1.0;
        }
        //else scale = (MAX_PIXEL_8BIT-1)/(1+(ceil(dataMax)-floor(dataMin)));
        else scale = MAX_PIXEL_8BIT/(dataMax-dataMin);
}


- (void)saveTIFFToFile:(NSString *)filename
{
	[[tiff TIFFRepresentation] writeToFile:filename atomically:NO];
}

- (NSBitmapImageRep *)bitmapImageRep
{
    return tiff;
}

- (void)setData:(NSData *)myData
{
    [self setData:myData byteOrder:NSHostByteOrder()];
}

- (void)setData:(NSData *)myData byteOrder:(unsigned)bo
{
	int	i,j;
	float *dataptr;
	unsigned char	pixelValue;

        swapBytesFlag = (bo == NSHostByteOrder()) ? NO : YES;

	[dataObject release];
	
	dataObject = [myData retain];

	dataptr = (float *)[myData bytes];
    [tiff getBitmapDataPlanes:imageData];
	
	[self _setAutoScale];
	
    for(i=0;i<tiffHeight;i++){
        for(j=0;j<tiffWidth;j++){
                int index = (i*tiffWidth)+j;
                if(dataptr[index]==POS_INFINITY)dataptr[index]=dataMax;
                if(dataptr[index]==NEG_INFINITY)dataptr[index]=dataMin;
                if(IS_NAN(dataptr[index]))dataptr[index]=dataMax;
                pixelValue= scale*(dataptr[index]-dataMin);
				//[tiff setColor:[NSColor whiteColor] atX:j y:j];
                //if(pixelValue>MAX_PIXEL_8BIT)pixelValue=MAX_PIXEL_8BIT;
                imageData[0][index]=pixelValue;
                //imageData[1][index]=pixelValue;
                //imageData[2][index]=pixelValue;
        }
    }
}

- (void)mouseDown:(NSEvent *)theEvent
{
    NSPoint mouseLoc;
    BOOL isInside = NO;
    
    theEvent = [[self window] nextEventMatchingMask: NSLeftMouseUpMask |
            NSLeftMouseDraggedMask];
    mouseLoc = [self convertPoint:[theEvent locationInWindow] fromView:nil];
    isInside = [self mouse:mouseLoc inRect:border];
    
    elementLoc.x = ceil((mouseLoc.x - NSMinX(border)) * (tiffWidth/NSWidth(border)) - 1.0);
    elementLoc.y = abs(ceil((mouseLoc.y - NSMinY(border)) * (tiffHeight/NSHeight(border))) - tiffHeight);
    
    //NSLog(@"%g %g\n",elementLoc.x,elementLoc.y);
    
#if 0
    switch ([theEvent type]) {
        case NSLeftMouseDragged:
                //[self highlight:isInside];
                break;
        case NSLeftMouseUp:
                break;
        default:
                /* Ignore any other kind of event. */
                break;
    };
#endif

    return;
}

- (NSPoint) selectedPoint
{
    return elementLoc;
}


- (void)setFrameSize:(NSSize)_newSize
// Allow resizing
{
	[super setFrameSize:_newSize];
}

- setHeight:(int)number{tiffHeight = number;return self;}
- setWidth:(int)number{tiffWidth = number;return self;}
- setMin:(float)number{autoScale=NO;dataMin = number;return self;}
- setMax:(float)number{autoScale=NO;dataMax = number;return self;}
- setMin:(float)min andMax:(float)max{autoScale=NO;dataMin=min;dataMax=max;return self;}
- (float) min{ return dataMin;}
- (float) max{ return dataMax;}

- (void) setReferenceValue: (float) val  // AKH
{ refValue = val; }

- setPreserveAspectRatio:(BOOL)state
{
	preserveAspectRatio = state;
	return self;
}

- setAutoScale:(BOOL)state
{
	autoScale = state;
	return self;
}

- toggleAutoScale:sender
{
    autoScale=!autoScale;
    [self displayIfNeeded];
    return self;
}

- togglePreserveAspectRatio:sender
{
    preserveAspectRatio=!preserveAspectRatio;
    [self displayIfNeeded];
    return self;
}

- (void)dealloc
{
    [tiff release];
    [super dealloc];
}

#undef min(x,y)
#undef max(x,y)
@end

