/* Generated by Interface Builder */

#import "SIMColorDataView.h"
#import <stdlib.h>

#define DEFAULTFONTSIZE 10
#define TWO_PI (M_PI*2)
#define COLOR_PERIOD (TWO_PI/MAX_PIXEL_8BIT)

NSComparisonResult sortColorKeys (id value1, id value2, void *context)
{
    float v1 = [value1 floatValue];
    float v2 = [value2 floatValue];
    
    if(v1 < v2)return NSOrderedAscending;
    if(v1 > v2)return NSOrderedDescending;

    return NSOrderedSame;
}

@implementation SIMColorDataView

- initWithFrame:(NSRect)frameRect
{
// Initialize the View and the variables describing the boundaries

    [super initWithFrame:frameRect];
                    
    dataObject = nil;

    colorTable = (unsigned char **)NSZoneMalloc((NSZone *)[self zone],sizeof(unsigned char *)*3);
    colorTable[0] = (unsigned char *)NSZoneCalloc((NSZone *)[self zone],sizeof(unsigned char), MAX_PIXEL_8BIT);
    colorTable[1] = (unsigned char *)NSZoneCalloc((NSZone *)[self zone],sizeof(unsigned char), MAX_PIXEL_8BIT);
    colorTable[2] = (unsigned char *)NSZoneCalloc((NSZone *)[self zone],sizeof(unsigned char), MAX_PIXEL_8BIT);

    rContrast = (1.0 - .88),
    rFreq = (.5*TWO_PI)/MAX_PIXEL_8BIT,
    rPhase = 0.*TWO_PI,
    gContrast = (1.0 - .5),
    gFreq = (.5*TWO_PI)/MAX_PIXEL_8BIT,
    gPhase = 0.*TWO_PI,
    bContrast = (1.0 -0.1),
    bFreq = (1.5*TWO_PI)/MAX_PIXEL_8BIT,
    bPhase = 0.*TWO_PI;

    hasColorBar = YES;
    colorbarWidth = 50.;
    colorbarInset = 20;
    colorbarOffset = -15;

    baselineValue = -35.0;
    colorPaletteMode = SIM_COLOR_PALETTE_LIST;

    [self _recalcRects];	
    [self _setColorScale];

    //startColor = [[NSColor blueColor] retain];
    //endColor = [[NSColor redColor] retain];
    //baselineColor = [[NSColor whiteColor] retain];

    //[self setHSBStartColor:startColor endColor:endColor];
    //[self setBaselineValue:baselineValue withColor:baselineColor minColor:startColor maxColor:endColor];

    colorbarFont = [NSFont fontWithName:@"Helvetica" size:DEFAULTFONTSIZE];
    [colorbarFont retain];

    [self setColorPaletteFromColorListWithName:nil];

    return self;
}

- initSize:(int)xsize :(int)ysize
{
	unsigned char *initData[5] = {NULL};
        initData[0] = NULL;
        initData[1] = NULL;
        initData[2] = NULL;
        initData[3] = NULL; 

	tiffWidth = xsize;
	tiffHeight = ysize;

	if(tiff)[tiff release];

	tiff = [[NSBitmapImageRep allocWithZone:[self zone]]
                    initWithBitmapDataPlanes:&initData[0]
                    pixelsWide:tiffWidth
                    pixelsHigh:tiffHeight
                    bitsPerSample:8
                    samplesPerPixel:3
                    hasAlpha:NO
                    isPlanar:YES
                    colorSpaceName:NSCalibratedRGBColorSpace
                    bytesPerRow:tiffWidth
                    bitsPerPixel:8];

	if(!tiff)NSLog(@"Couldn't create tiff!\n");
	[tiff getBitmapDataPlanes:(unsigned char **)imageData];
    
	return self;
}

- (void)drawRect:(NSRect)rects
// This is the routine where everything really happens
// The background of the view is drawn and then the function itself
// is calculated.  The parameters used are global to this class, so
// the sliders can change them at any time.
{			
	float	fontHeight;
	
    [[[self window] backgroundColor] set];
	NSRectFill([self bounds]);
    //return;
	
	if(tiff){
                [[NSColor blackColor] set];
		if(hasColorBar){
			[colorScale drawInRect:colorbarBorder];
			NSFrameRectWithWidth(colorbarBorder , 0.);
            //TIMEDIT
			[colorbarFont set];
            //[(NSFont *)[NSFont fontWithName:@"Helvetica" size:DEFAULTFONTSIZE] set];
            //Fonts are horribly horribly broken in 10.4+ this is a hardcoded change
			//fontHeight = [colorbarFont defaultLineHeightForFont];
            fontHeight = 10;
                        [[NSString stringWithFormat:@"%g",dataMin] 
                            drawAtPoint:NSMakePoint(colorbarBorder.origin.x+colorbarBorder.size.width+2.0,colorbarBorder.origin.y) 
                            withAttributes:nil];
                        [[NSString stringWithFormat:@"%g",dataMax] 
                            drawAtPoint:NSMakePoint(colorbarBorder.origin.x+colorbarBorder.size.width+2.0,
                            colorbarBorder.origin.y+colorbarBorder.size.height-fontHeight) 
                            withAttributes:nil];

			//PSmoveto(colorbarBorder.origin.x+colorbarBorder.size.width+2.0,
			//		colorbarBorder.origin.y);
			//PSshow([[NSString stringWithFormat:@"%g",dataMin] cString]);
			//PSmoveto(colorbarBorder.origin.x+colorbarBorder.size.width+2.0,
			//		colorbarBorder.origin.y+colorbarBorder.size.height-fontHeight);
			//PSshow([[NSString stringWithFormat:@"%g",dataMax] cString]);
		}
                
                //[[NSGraphicsContext currentContext] setShouldAntialias:NO];
		if(imageSmoothingFlag)[[NSGraphicsContext currentContext] setImageInterpolation:NSImageInterpolationLow];
		else [[NSGraphicsContext currentContext] setImageInterpolation:NSImageInterpolationNone];
		bool f = [tiff drawInRect:border];
		NSFrameRectWithWidth(border , 1.);
	}
}

- (void)setFrameSize:(NSSize)_newSize
// Allow resizing
{
	[super setFrameSize:_newSize];
	[self _recalcRects];
}

- (void)_recalcRects
{
	border = [self bounds];	
	
	border = NSInsetRect(border , 2. , 2.);
	border = NSOffsetRect(border , 1. , 0.);

	if(hasColorBar){
		NSDivideRect(border , &colorbarBorder , &border , colorbarWidth, NSMaxXEdge);
		colorbarBorder = NSInsetRect(colorbarBorder , colorbarInset , 0.);
		colorbarBorder = NSOffsetRect(colorbarBorder , colorbarOffset , 0.);
	}
	
	if(hasColorBar){
		colorbarBorder.size.height = border.size.height;
		colorbarBorder.origin.y = border.origin.y;
		colorbarBorder = NSIntegralRect(colorbarBorder);
	}

	if(preserveAspectRatio){
            float	imageRatio;
    
            //PSsetgray(NSLightGray);
            NSRectFill([self bounds]);


            imageRatio = 
                MIN(((border.size.width)/tiffWidth),(border.size.height/tiffHeight));
    
            border.size.width = tiffWidth*imageRatio;
            border.size.height = tiffHeight*imageRatio;
            border.origin.x += (([self bounds].size.width-colorbarWidth)/2) - 
                    (border.size.width/2);
            border.origin.y += ([self bounds].size.height/2) - 
                    (border.size.height/2);
	}
	
	border = NSIntegralRect(border);
}
	
- (void)_setColorScale
{
	int	scaleWidth = 1;
	int	scaleHeight = MAX_PIXEL_8BIT;


	if(colorScale){[colorScale release]; colorScale=nil;}

	colorScale = [[NSBitmapImageRep allocWithZone:[self zone]] initWithBitmapDataPlanes:colorTable pixelsWide:scaleWidth pixelsHigh:scaleHeight bitsPerSample:8 samplesPerPixel:3 hasAlpha:NO isPlanar:YES colorSpaceName:NSCalibratedRGBColorSpace bytesPerRow:scaleWidth bitsPerPixel:8];

	if(!colorScale)NSLog(@"Couldn't create tiff!\n");
}
int asdf = 0;

- (void)setData:(NSData *)myData byteOrder:(unsigned)bo
{
    int	i,j;
    unsigned char	pixelValue;
    unsigned char 	*imageData0, *imageData1, *imageData2;
    NSSwappedFloat 	*myptr;
	
    swapBytesFlag = (bo == NSHostByteOrder()) ? NO : YES;

    if(dataObject)[dataObject autorelease];

    dataObject = [myData retain];

    myptr = (NSSwappedFloat *)[dataObject bytes];

    [self _setAutoScale];

    if(colorPaletteMode == SIM_COLOR_PALETTE_BASELINE)
    [self setBaselineValue:baselineValue withColor:baselineColor minColor:startColor 
		maxColor:endColor];

    //TIMEDIT <-- quick hack to get around the NSImage->CGImage caching problem
    [tiff getBitmapDataPlanes:(unsigned char **)imageData];
    
    imageData0 = &(imageData[0][0]);
    imageData1 = &(imageData[1][0]);
    imageData2 = &(imageData[2][0]);
    unsigned char r, g, b;

    asdf++;
    
    for(i=0;i<tiffHeight;i++){
        for (j = 0; j < tiffWidth; j++, myptr++) {
            
            //*imageData0++ = ((asdf)%8) * 32;
            //*imageData1++ = ((asdf+2)%8) * 32;
            //*imageData2++ = ((asdf+4)%8) * 32;
            //continue;
            
            float tmpValue;
            
            if(swapBytesFlag)*myptr =  NSSwapFloat(*myptr);
            tmpValue =  NSConvertSwappedFloatToHost(*myptr);
            
           if(tmpValue==NEG_INFINITY){
                *imageData0++ = colorTable[0][(MAX_PIXEL_8BIT)/2];
                *imageData1++ = colorTable[0][(MAX_PIXEL_8BIT)/2];
                *imageData2++ = colorTable[0][(MAX_PIXEL_8BIT)/2];
           }
           else if(IS_NAN(tmpValue)) {
               *imageData0++ = 0;
               *imageData1++ = 0;
               *imageData2++ = 0;
           }
           else if(tmpValue==POS_INFINITY){
               *imageData0++ = colorTable[2][(MAX_PIXEL_8BIT)/2];
               *imageData1++ = colorTable[2][(MAX_PIXEL_8BIT)/2];
               *imageData2++ = colorTable[2][(MAX_PIXEL_8BIT)/2];
           }
           else {
                if (tmpValue !=refValue) {
                    pixelValue = scale * (tmpValue - dataMin);
                    r = colorTable[0][(MAX_PIXEL_8BIT)-pixelValue];
                    g = colorTable[1][(MAX_PIXEL_8BIT)-pixelValue];
                    b = colorTable[2][(MAX_PIXEL_8BIT)-pixelValue];
                    (*imageData0) = 255;
                    imageData0++;
                    (*imageData1) = b;
                    imageData1++;
                    (*imageData2) = g;
                    imageData2++;
                }
                else {
                    *imageData0++ = colorTable[0][(MAX_PIXEL_8BIT)];
                    *imageData1++ = colorTable[0][(MAX_PIXEL_8BIT)];
                    *imageData2++ = colorTable[0][(MAX_PIXEL_8BIT)];
                }
            }
        }
    }
    [self setNeedsDisplay:TRUE];
    [self displayIfNeeded];
    //[tiff draw];
}
 

- (void)setBaselineValue:(float)baseValue withColor:(NSColor *)baseColor minColor:(NSColor *)minColor
    maxColor:(NSColor *)maxColor
{
    int i, baseIndex;
    float	maxR,maxG,maxB,minR,minG,minB,red,green,blue,rinc,ginc,binc,frac;

	if(startColor)[startColor autorelease];
	startColor = [minColor copy];
	if(endColor)[endColor autorelease];
	endColor = [maxColor copy];
	baselineValue = baseValue;
	if(baselineColor)[baselineColor autorelease];
	baselineColor = [baseColor copy];
    colorPaletteMode = SIM_COLOR_PALETTE_BASELINE;

    [[maxColor colorUsingColorSpaceName:NSCalibratedRGBColorSpace] getRed:&maxR green:&maxG
        blue:&maxB alpha:NULL];		
    [[minColor colorUsingColorSpaceName:NSCalibratedRGBColorSpace] getRed:&minR green:&minG
        blue:&minB alpha:NULL];

    [[baseColor colorUsingColorSpaceName:NSCalibratedRGBColorSpace] getRed:&red green:&green
        blue:&blue alpha:NULL];		

    if(baseValue < dataMin) baseValue = dataMin;
    if(baseValue > dataMax) baseValue = dataMax;

	// Calculate the relative position of the baseValue into the colorTable
    frac = fabs(baseValue)/(dataMax - dataMin);
    if(IS_STRANGE(frac)) frac = .5;
    baseIndex = frac * MAX_PIXEL_8BIT;

    rinc = (maxR - red)/(baseIndex);
    ginc = (maxG - green)/(baseIndex);
    binc = (maxB - blue)/(baseIndex);

    for(i = baseIndex; i >= 0; i--){
        colorTable[0][i] = (red += rinc)*MAX_PIXEL_8BIT;
        colorTable[1][i] = (green += ginc)*MAX_PIXEL_8BIT;
        colorTable[2][i] = (blue += binc)*MAX_PIXEL_8BIT;
    }

    [[baseColor colorUsingColorSpaceName:NSCalibratedRGBColorSpace] getRed:&red green:&green
        blue:&blue alpha:NULL];		

    rinc = (minR - red)/((MAX_PIXEL_8BIT+1) - baseIndex);
    ginc = (minG - green)/((MAX_PIXEL_8BIT+1) - baseIndex);
    binc = (minB - blue)/((MAX_PIXEL_8BIT+1) - baseIndex);

    for(i = baseIndex; i <= MAX_PIXEL_8BIT; i++){
        colorTable[0][i] = (red += rinc)*MAX_PIXEL_8BIT;
        colorTable[1][i] = (green += ginc)*MAX_PIXEL_8BIT;
        colorTable[2][i] = (blue += binc)*MAX_PIXEL_8BIT;
    }
}

- (void)setColorPaletteFromColorListWithName:(NSString *)listName
{
    NSColorList *cList;
    
    if(listName)cList = [NSColorList colorListNamed:listName];
    else {
        NSString *colorPath;
        colorPath = [[NSBundle bundleForClass:[self class]] pathForResource:@"Default" ofType:@"clr"];
	cList = [[NSColorList alloc] initWithName:@"" fromFile:colorPath];
    }
    [self setColorPaletteFromColorList:cList];
}

- (void)setColorPaletteFromColorList:(NSColorList *)cList
{
    CGFloat colorMin, colorMax, cScale, cOffset;
    int startValue, endValue;
    NSString *colorKey;
    NSArray *colorKeys = [[cList allKeys] sortedArrayUsingFunction:sortColorKeys context:nil];
    NSEnumerator *colorEnum = [colorKeys reverseObjectEnumerator];
    
    if(!cList)NSLog(@"ERROR: No valid color list found");
    
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleColorListChangedNotification:) name:NSColorListDidChangeNotification object:cList];

    [cList retain];
    
    [self setAutoScale:NO];
        
    colorMax = [[colorKeys objectAtIndex:0] floatValue]; // Colors must be named with numeric values
    colorMin = [[colorKeys lastObject] floatValue]; // and ordered from min to max
        
    cScale = MAX_PIXEL_8BIT/(colorMax - colorMin);
    
    cOffset = colorMin*cScale;
    startValue = 0;
    startColor = [cList colorWithKey:[colorKeys lastObject]];
    while(colorKey = [colorEnum nextObject]){
        int i, cLength;
	CGFloat	r1,g1,b1,r2,g2,b2,rinc,ginc,binc;

        endValue = [colorKey floatValue]*cScale - cOffset;
        endColor = [cList colorWithKey:colorKey];
        cLength = (endValue - startValue);
                
	[[startColor colorUsingColorSpaceName:NSCalibratedRGBColorSpace] getRed:&r1 green:&g1 blue:&b1 alpha:NULL];		
	[[endColor colorUsingColorSpaceName:NSCalibratedRGBColorSpace] getRed:&r2 green:&g2 blue:&b2 alpha:NULL];

	rinc = (r2 - r1)/cLength;
	ginc = (g2 - g1)/cLength;
	binc = (b2 - b1)/cLength;

        for(i = startValue; i < endValue; i++){
            colorTable[0][i] = (r1+=rinc)*MAX_PIXEL_8BIT;
            colorTable[1][i] = (g1+=ginc)*MAX_PIXEL_8BIT;
            colorTable[2][i] = (b1+=binc)*MAX_PIXEL_8BIT;
        }
        startValue = endValue;
        startColor = endColor;
    }
    
    dataMin = colorMin;
    dataMax = colorMax;
    scale = cScale;
    
    [cList release];
}

- (void)handleColorListChangedNotification:(NSNotification *)n
{
    [self setColorPaletteFromColorList:[n object]];
    [self setNeedsDisplay:YES];
}

- setColorPaletteMode:sender
{
	colorPaletteMode = [sender intValue];
	return self;
}


- setStartColor:sender
{
    [startColor autorelease];
    startColor = [[sender color] retain];
    return self;
}

- setEndColor:sender
{
    [endColor autorelease];
    endColor = [[sender color] retain];
    return self;
}

- setBaselineColor:sender
{
    [baselineColor autorelease];
    baselineColor = [[sender color] retain];
    return self;
}

- takeBaselineValueFromSender:sender
{
	baselineValue = [sender floatValue];
    return self;
}


- setRGBStartColor:sender
{
    if(!endColor)endColor = [NSColor blackColor];
	[startColor autorelease];
	startColor = [[sender color] retain];
	[self setRGBStartColor:[sender color] endColor:endColor];
	return self;
}

- setRGBEndColor:sender
{
    if(!startColor)startColor = [NSColor whiteColor];
    [endColor autorelease];
    endColor = [[sender color] retain];
    [self setRGBStartColor:startColor endColor:endColor];
	return self;
}

		
- (void)setRGBStartColor:(NSColor *)color1 endColor:(NSColor *)color2
{ 
	int	i;
	float	r1,g1,b1,r2,g2,b2,rinc,ginc,binc;
	
	[[color1 colorUsingColorSpaceName:NSCalibratedRGBColorSpace] getRed:&r1 green:&g1 blue:&b1 alpha:NULL];		
	[[color2 colorUsingColorSpaceName:NSCalibratedRGBColorSpace] getRed:&r2 green:&g2 blue:&b2 alpha:NULL];

	rinc = (r2 - r1)/MAX_PIXEL_8BIT;
	ginc = (g2 - g1)/MAX_PIXEL_8BIT;
	binc = (b2 - b1)/MAX_PIXEL_8BIT;

	for(i=0;i<=MAX_PIXEL_8BIT;i++){
		colorTable[0][i] = (r1+=rinc)*MAX_PIXEL_8BIT;
		colorTable[1][i] = (g1+=ginc)*MAX_PIXEL_8BIT;
		colorTable[2][i] = (b1+=binc)*MAX_PIXEL_8BIT;
	}

	if(dataObject)[self setData:dataObject];
}

- (void)setHSBStartColor:(NSColor *)color2 endColor:(NSColor *)color1
{ 
	int	i;
	float	hue1,sat1,bri1,hue2,sat2,bri2,hinc,sinc,binc;
	float	r,g,b;
	
	[[color1 colorUsingColorSpaceName:NSCalibratedRGBColorSpace] getHue:&hue1 saturation:&sat1 brightness:&bri1 alpha:NULL];		
	[[color2 colorUsingColorSpaceName:NSCalibratedRGBColorSpace] getHue:&hue2 saturation:&sat2 brightness:&bri2 alpha:NULL];

	hinc = (hue2 - hue1)/MAX_PIXEL_8BIT;
	sinc = (sat2 - sat1)/MAX_PIXEL_8BIT;
	binc = (bri2 - bri1)/MAX_PIXEL_8BIT;

	for(i=0;i<=MAX_PIXEL_8BIT;i++){
		hue1+=hinc;
		sat1+=sinc;
		bri1+=binc;
	[[[NSColor colorWithCalibratedHue:hue1 saturation:sat1 brightness:bri1 alpha:1.0] colorUsingColorSpaceName:NSCalibratedRGBColorSpace] getRed:&r green:&g blue:&b alpha:NULL];
		colorTable[0][i] = (r)*MAX_PIXEL_8BIT;
		colorTable[1][i] = (g)*MAX_PIXEL_8BIT;
		colorTable[2][i] = (b)*MAX_PIXEL_8BIT;
	}

	if(dataObject)[self setData:dataObject];
} 

- setHSBStartColor:sender
{
    if(!endColor)endColor = [NSColor blackColor];
    [startColor autorelease];
    startColor = [[sender color] retain];
    [self setHSBStartColor:[sender color] endColor:endColor];
	return self;
}

- setHSBEndColor:sender
{
    if(!startColor)startColor = [NSColor whiteColor];
    [endColor autorelease];
    endColor = [[sender color] retain];
    [self setHSBStartColor:startColor endColor:endColor];
	return self;
}



- (void)setHSBPalette
{
	int	i;
	float	r,g,b;
	
	for(i=0;i<=MAX_PIXEL_8BIT;i++){
		[[[NSColor colorWithCalibratedHue:(float)i/MAX_PIXEL_8BIT saturation:1.0 brightness:1.0 alpha:1.0] colorUsingColorSpaceName:NSCalibratedRGBColorSpace] getRed:&r green:&g blue:&b alpha:NULL];
		colorTable[0][i] = r*MAX_PIXEL_8BIT;
		colorTable[1][i] = g*MAX_PIXEL_8BIT;
		colorTable[2][i] = b*MAX_PIXEL_8BIT;
	}

	if(dataObject)[self setData:dataObject];
}

- (void)setSYNTHPalette
{
	int	i;
	int	HALF = MAX_PIXEL_8BIT*.5;

	for(i=0;i<=MAX_PIXEL_8BIT;i++){
		colorTable[0][i] = rContrast*( HALF+ HALF* cos(rFreq*(float)i+rPhase));
		colorTable[1][i] = gContrast*( HALF+ HALF* cos(gFreq*(float)i+gPhase));
		colorTable[2][i] = bContrast*( HALF+ HALF* cos(bFreq*(float)i+bPhase));
	}


	if(dataObject)[self setData:dataObject];
}

- toggleColorBar:sender
{
	hasColorBar=!hasColorBar;
	[self _recalcRects];
	[self displayIfNeeded];
	return self;
}

- cyclePaletteUp:sender
{
	[self shiftPaletteUp];
    [self displayIfNeeded];
	return self;
}

- cyclePaletteDown:sender
{
	[self shiftPaletteDown];
    [self displayIfNeeded];
	return self;
}

- (void)shiftPaletteUp
{
	float	r,g,b;
	
	r = colorTable[0][0];
	g = colorTable[1][0];
	b = colorTable[2][0];
	
	memmove(colorTable[0],colorTable[0]+1, MAX_PIXEL_8BIT-1);
	memmove(colorTable[1],colorTable[1]+1, MAX_PIXEL_8BIT-1);
	memmove(colorTable[2],colorTable[2]+1, MAX_PIXEL_8BIT-1);

	colorTable[0][MAX_PIXEL_8BIT-1] = r;
	colorTable[1][MAX_PIXEL_8BIT-1] = g;
	colorTable[2][MAX_PIXEL_8BIT-1] = b;

	if(dataObject)[self setData:dataObject];
}

- (void)shiftPaletteDown
{
	float	r,g,b;
	
	r = colorTable[0][MAX_PIXEL_8BIT-1];
	g = colorTable[1][MAX_PIXEL_8BIT-1];
	b = colorTable[2][MAX_PIXEL_8BIT-1];
	
	memmove(colorTable[0]+1,colorTable[0], MAX_PIXEL_8BIT-1);
	memmove(colorTable[1]+1,colorTable[1], MAX_PIXEL_8BIT-1);
	memmove(colorTable[2]+1,colorTable[2], MAX_PIXEL_8BIT-1);

	colorTable[0][0] = r;
	colorTable[1][0] = g;
	colorTable[2][0] = b;

	if(dataObject)[self setData:dataObject];
}

- setRedPhase:sender{
	rPhase = TWO_PI*[sender doubleValue];
	[self setSYNTHPalette];
    [self displayIfNeeded];
	return self;
}
- setGreenPhase:sender{
	gPhase = TWO_PI*[sender doubleValue];
	[self setSYNTHPalette];
    [self displayIfNeeded];
	return self;
}
	
- setBluePhase:sender{
	bPhase = TWO_PI*[sender doubleValue];
	[self setSYNTHPalette];
    [self displayIfNeeded];
	return self;
}
- setRedFrequency:sender{
	rFreq=COLOR_PERIOD*[sender doubleValue];
	[self setSYNTHPalette];
    [self displayIfNeeded];
	return self;
}
- setGreenFrequency:sender{
	gFreq=COLOR_PERIOD*[sender doubleValue];
	[self setSYNTHPalette];
    [self displayIfNeeded];
	return self;
}
- setBlueFrequency:sender{
	bFreq=COLOR_PERIOD*[sender doubleValue];
	[self setSYNTHPalette];
    [self displayIfNeeded];
	return self;
}
- setRedContrast:sender{
	rContrast = (1.0-[sender doubleValue]);
	[self setSYNTHPalette];
    [self displayIfNeeded];
	return self;
}
- setGreenContrast:sender{
	gContrast = (1.0-[sender doubleValue]);
	[self setSYNTHPalette];
    [self displayIfNeeded];
	return self;
}
- setBlueContrast:sender{
	bContrast = (1.0-[sender doubleValue]);
	[self setSYNTHPalette];
    [self displayIfNeeded];
	return self;
}

- (void)dealloc
{
    [colorbarFont release];
    [super dealloc];
}


@end

